# 딥다이브 주차 별 정리

## 개요
### 1. 함수
### 2. 스코프
### 3. 전역 변수의 문제점
### 4. let, const 키워드와 블록 레벨 스코프
### 5. this
### 6. 실행 컨텍스트
### 7. 클로저
<br>

## 함수

프로그래밍 언어의 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것.

<br>

**함수를 사용하는 이유?**
- 코드의 재사용면에서 매우 유용
- 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높임
- 코드의 가독성을 향상시킴

<br/>

**1. 함수 선언문**
- 함수 이름을 생략할 수 없음 (기명 함수)
- 함수 선언문은 표현식이 아닌 문
- **함수 선언문이 호이스팅 됨**
```javascript
// 함수 선언문
function add(x, y) {
  return x + y;
}
```

**2. 함수 표현식**
- 자바스크립트의 함수는 **일급 객체**이므로 함수를 값처럼 자유롭게 사용할 수 있음
- **변수가 호이스팅이 됨**
```javascript
// 함수 표현식
var add = function (x, y) { // 함수 이름 생략 가능(익명 함수)
  return x + y;
};
```

**일급 객체**란? <br>
> 자바스크립트의 함수는 객체 타입의 값이다. <br>
자바스크립트의 함수는 값처럼 변수에 할당 할 수도 있고 프로퍼티 값이 될 수도 있으며 배열의 요소가 될 수 도 있다. <br>
이 처럼 **값의** 성질을 갖는 **객체를 일급 객체**라고 한다. <br>
즉, **자바스크립트의 함수는 일급객체다.** 함수가 일급객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미다.

<br>

**3. 화살표 함수 (ES6)**
- function 키워드 대신 화살표 `=>`를 사용해 좀 더 간략한 방법으로 함수를 선언
- 화살표 함수는 항상 익명 함수로 정의
```javascript
// 화살표 함수
const add = (x, y) => x + y;
```

<br/>

## 참조에 의한 전달과 외부 상태의 변경 / 함수형 프로그래밍
원시 값은 값에 의한 전달, 객체는 참조에 의한 전달 방식으로 동작. 매개변수도 함수 몸체 내부에서 변수와 동일하게 취급되므로 매개변수 또한 타입에 따라 값에 의하 전달, 참조에 의한 전달 방식을 그대로 따른다.

```javascript
      // 매개변수 primitive는 원시 값을 전달받고, 매개변수 obj는 객체를 전달받는다.
      function changeVal(primitive, obj) {
          primitive += 100
          obj.name = 'Kim'
        }

      // 외부 상태
      var num = 100;
      var person = { name : 'Lee' };

      console.log(num); // 100
      console.log(person);  // {name:"Lee"}

      // 원시 값은 자체가 복사되어 전달되고 객체는 참조 값이 복사되어 전달된다.
      changeVal(num, person);

      // 원시 값은 원본이 훼손되지 않는다.
      console.log(num); // 100

      // 참조 값(객체)은 원본이 훼손된다.
      console.log(person);  // {name:"Kim"}
```

위 코드에서 changeVal 함수는 매개변수를 통해 전달받은 원시 타입 인수와 객체 타입 인수를 **함수 몸체에서 변경한다.** <br>
엄밀히 말하자면 원시 타입 인수 primitive의 경우 직접 변경할 수 없기 때문에 재할당을 통해 할당된 원시 값을 새로운 값으로 교체.
객체 타입의 인수 obj 경우 객체(참조 타입의) 값은 변경 가능한 값이므로 재할당 없이 직접 할당된 객체를 변경했다. <br>

<br>

**다시 말해 함수 몸체에서 원본이 훼손되지 않는 경우와 되는 경우는**
- 원시 타입 인수는 값 자체가 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 그 값을 변경해도 원본은 훼손되지 않는다.
- 참조 타입 인수는 참조 값이 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 참조 값을 통해 객체를 변경할 경우 원본이 훼손된다.
<br>
이처럼 함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워진다. 이는 코드의 복잡성을 증가시키고 가독성을 해치는 원인이 된다.
<br>

외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 순수 함수라 한다. 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임을 **함수형 프로그래밍이라** 한다.

<br>

## 스코프
모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 **선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다.** 이를 스코프라 한다. 

<br>

즉, **스코프는 식별자의 유효한 범위를 말한다.**  
<br>

```JS
var x = 'global'

function foo() {
  var x = 'local'
  console.log(x);  // 'local'
}

foo()

console.log(x); // 'global'
```
<br>

위 예제에서 볼 수 있듯이 자바스크립트 엔진은 이름이 같은 두개의 변수에서 어떤 변수를 참조할 지 결정하는데 이를 **식별자 결정이라** 한다.<br>

자바스크립트 엔진은 코드를 실행할 때 코드의 문맥을 고려한다. 코드가 어디서 실행되며 어떤 코드가 있는지에 따라 문맥에 맞게 동일한 코드도 다른 결과를 만들어 낼 수 있다.

<br>

**코드의 문맥과 환경**
> "코드가 어디서 실행되며 주변에 어떤 코드가 있는지"를 **렉시컬 환경(lexical environment)** 이라고 부른다. 즉, 코드의 문맥은 렉시컬 환경으로 이뤄진다. <br>
이를 구현한 것이 **"실행 컨텍스트(excution context)"** 이며, 모든 코드들은 실행 컨텍스트에서 평가되고 실행된다.
<br>


**var :** 함수 레벨 스코프 지원<br/>
**let, const :** 블록 레벨 스코프 지원

**호이스팅은 스코프 단위로 동작**

<br>

## 스코프 체인

스코프가 **함수의 중첩에 의해 계층적 구조**를 갖는 것

**상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없음**

<br>

## 렉시컬 스코프

함수를 **어디서 정의**했는지에 따라 함수의 상위 스코프 결정
⇒ **렉시컬 스코프** 또는 **정적 스코프**라고 부름

<br>

## var, let, const

**1. var**
- 함수레벨 스코프
- 변수 중복 선언 가능
- 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작
	**⇒ "선언단계"와 "초기화 단계"가 같이 발생**

**2. let**
- 블록레벨 스코프
- 변수 중복 선언 불가능 (SyntaxError 발생)
- 변수 호이스팅이 발생하지 않는 것처럼 동작
	**⇒ "선언단계"와 "초기화 단계"가 분리되어 진행**
  
	스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 **일시적 사각지대(Temporal Dead Zone; TDZ)라고 부름**

  <img src="https://velog.velcdn.com/images/smh0116/post/87ff58f7-4352-4f0b-8afe-2a350278971d/image.png" alt="" width="350" />

	```javascript
	// 런타임 이전에 선언 단계가 실행. 아직 변수가 초기화되지 않음
	// 초기화 이전의 일시적 사각지대에서는 변수를 참조할 수 없음
	console.log(foo); // ReferenceError: foo is not defined

	let foo; // 변수 선언문에서 초기화 단계가 실행
	console.log(foo); // undefined

	foo = 1; // 할당문에서 할당 단계가 실행
	console.log(foo); // 1
	```
	

**3. const**
- 블록 레벨 스코프
- 반드시 선언과 동시에 초기화해야함
- let 키워드와 마찬가지로 변수 호이스팅이 발생하지 않는 것처럼 동작
- 재할당 금지
- 객체를 할당한 경우 값을 변경할 수 있음 (객체는 재할당 없이도 직접 변경이 가능하기 때문)

<br/>


