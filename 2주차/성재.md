## 함수
- 함수는 함수 객체를 가리키는 식별자로 호출한다.
 <br/>

1. 함수선언문
    ```jsx
    function add(x,y) {
    return x + y;
    }
    ```
    - 함수 선언문은 이름을 생략할 수 없다.
    - 표현식이 아닌 문이다.
    - 함수 선언문이 호이스팅 된다 (함수 호이스팅)
<br/>

2. 함수 표현식
   ```jsx
    var add = function(x,y) {
    return x + y;
    }
    ```
   - 변수 호이스팅이 된다. (함수 호이스팅이 되지 않아 함수를 선언한 뒤에 호출가능해서 사용이 권장됨)
<br/>

3. 화살표 함수
   ```jsx
   var add = (x,y) => x + y;
   ```
   - this 바인딩이 다르고, prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않는다.
 <br/>
 
4. function 생성자 함수
   - 클로저를 생성하지않고 일반적이지 않고 바람직하지 않다
<br/>
  
## 함수형 프로그래밍 이란?
  외부 상태를 변경하지 않는 순수 함수를 통해 오류를 피하고 안정성을 놏이려는 프로그래밍 패러다임.
<br/>

## 객체지향 프로그래밍 이란?
  함수 또는 명령어의 목록으로 보는 정통적인 명령형 프로그래밍의 절차자향적 관점에서 벗어나 독립적인 객체들의 집합으로 프로그램을 표현하려 하는 것
  - 객체는 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적 자료 구조인데 상태 데이터인 프로퍼티와 동작인 메서드를 묶는 복합적 자료구조이다.
  - 상속은 객체지향 프로그래밍의 핵심 개념으로 프로퍼티나 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것이다.
<br/>

## 콜백 함수와 고차 함수
  매개변수를 통해 다른 함수 내부로 전달되는 함수 => 콜백 함수
  콜백 함수를 전달 받은 함수 => 고차 함수
<br/>

## 스코프란?
  식별자가 유효한 범위를 말한다.
  - var로 선언된 변수는 함수 레벨 스코프 지원
  - let, const로 선언된 변수는 블록 레벨 스코프 지원
  - 스코프를 통해 변수 이름의 충돌을 방지하고 다른 스코프라면 같은 이름을 사용 가능하게 한다. 즉, 스코프는 네임 스페이스다.
  - 호이스팅은 스코프 단위로 동작한다. (변수 선언이 스코프 선두로 끌어 올려진 것처럼 동작하는것)
    - var로 선언된 변수는 할당시에 선언과 초기화가 같이 일어남
    - let은 선언과 초기화가 분리되어 일어남 초기화는 할당되기 직전에 일어나는데 선언이 되고나서 초기화 되기까지의 구간은 일시작 사각지대(TDZ) 라고한다.
    - const로 선언된 변수는 반드시 선언과 동시에 초기화 해야한다.(호이스팅은 let과 같은 원리로 일어남) var,let 과 달리 const는 재할당이 금지된다. (상수는 재할당이 금지된 변수 => const 로 선언된 변수 but 재할당이 금지 되었을 뿐이지 할당된 객체의 경우 변경이 가능하다.)
  - 변수의 스코프는 좁을수록 좋다. (생명주기[life cycle]가 길면 메모리 리소스 소비 의도치 않은 재할당이 일어난다)
<br/>

## 스코프 체인이란?
  스코프가 하나의 계층적 구조로 연결된 것
  - 스코프 체인을 통하여 상위 스코프로 이동하며 변수를 검색한다.
    - 상위 스코프의 변수는 하위 스코프에서 참조 가능하지만 하위 스코프의 변수는 상위 스코프에서 참조할 수 없다.
<br/>

## 렉시컬 스코프란?
  정적 스코프라고도 하며 함수 정의(함수 선언문, 함수 표현식)가 실행될 때 정적으로 결정한다.
<br/>

## 캡슐화란?
  객체의 상태를 나태내는 프로퍼티와 메서드를 하나로 묶는 것
  - 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 함 [정보 은닉]
<br/>

## 프로토타입이란?
  어떤 객체의 상위 객체의 역할을 하는 객체이다.
  - 프로토타입은 하위 객체에게 자신의 프로퍼티와 메서드를 상속한다.
<br/>

## this
  객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수
  - 렉시컬 스코프는 함수 정의가 평가되어 실행되는 시점에 결정되고 this 바인딩은 함수 호출 시점에 결정된다.
  - this가 가리키는값 => this 바인딩은 함수 호출 방식에 따라 동적으로 결정됨
   - 일반함수 = 전역 객체
   - 메서드 = 메서드를 호출한 객체
   - 생성자 함수 = 미래의 인스턴스
<br/>

## 바인딩이란?
  식별자와 값을 연결하는 과정 this 바인딩은 this가 가리킬 객체를 바인딩하는것
  - 바인딩: 변수와 값을 "연결"하는 과정.
  - 할당: 변수에 값을 "저장"하거나 "교체"하는 과정.
    - 바인딩은 프로그램이 변수나 값을 어떻게 처리할지 결정하는 초기 작업이고, 할당은 실행 중에 변수의 값을 설정하거나 변경하는 작업이라고 볼 수 있다.
<br/>
   
## 실행 컨텍스트란?
  소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행결과를 실제로 관리하는 영역! 모든코드는 실행컨텍스트를 통해 실행되고 관리된다.
  - 실행컨텍스트는 렉시컬 환경(식별자, 스코프 관리 like 저장소)과 실행컨텍스트 스택(코드 실행 순서 관리)으로 구성
  - 식별자를 등록하고 관리
  - 스코프와 코드 실행순서 관리
<br/>


