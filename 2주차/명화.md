
# 함수

일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것

<br/>

**함수를 사용하는 이유?**
- 코드의 재사용면에서 매우 유용
- 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높임
- 코드의 가독성을 향상시킴

<br/>

**1. 함수 선언문**
- 함수 이름을 생략할 수 없음 (기명 함수)
- 함수 선언문은 표현식이 아닌 문
- **함수 선언문이 호이스팅 됨**
```javascript
// 함수 선언문
function add(x, y) {
  return x + y;
}
```

**2. 함수 표현식**
- 자바스크립트의 함수는 일급 객체이므로 함수를 값처럼 자유롭게 사용할 수 있음
- **변수가 호이스팅이 됨**
```javascript
// 함수 표현식
var add = function (x, y) { // 함수 이름 생략 가능(익명 함수)
  return x + y;
};
```

**3. 화살표 함수 (ES6)**
- function 키워드 대신 화살표 `=>`를 사용해 좀 더 간략한 방법으로 함수를 선언
- 화살표 함수는 항상 익명 함수로 정의
```javascript
// 화살표 함수
const add = (x, y) => x + y;
```

<br/>

# 콜백함수 / 고차함수

**콜백 함수 :** 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수<br/>
**고차 함수 :** 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수

콜백 함수는 고차 함수에 의해 호출되며, 이때 고차 함수는 필요에 따라 콜백 함수에 인수는 전달할 수 있음

<br/>

# 스코프

모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 **자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정**되는 것

**⇒ 스코프는 식별자가 유효한 범위**

**var :** 함수 레벨 스코프 지원<br/>
**let, const :** 블록 레벨 스코프 지원

**호이스팅은 스코프 단위로 동작**

<br/>

# 스코프 체인

스코프가 **함수의 중첩에 의해 계층적 구조**를 갖는 것

**상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없음**

<br/>

# 렉시컬 스코프

함수를 **어디서 정의**했는지에 따라 함수의 상위 스코프 결정
⇒ **렉시컬 스코프** 또는 **정적 스코프**라고 부름

<br/>

# var, let, const

**1. var**
- 함수레벨 스코프
- 변수 중복 선언 가능
- 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작
	**⇒ "선언단계"와 "초기화 단계"가 같이 발생**

**2. let**
- 블록레벨 스코프
- 변수 중복 선언 불가능 (SyntaxError 발생)
- 변수 호이스팅이 발생하지 않는 것처럼 동작
	**⇒ "선언단계"와 "초기화 단계"가 분리되어 진행**
  
	스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 **일시적 사각지대(Temporal Dead Zone; TDZ)라고 부름**

  <img src="https://velog.velcdn.com/images/smh0116/post/87ff58f7-4352-4f0b-8afe-2a350278971d/image.png" alt="" width="350" />

	```javascript
	// 런타임 이전에 선언 단계가 실행. 아직 변수가 초기화되지 않음
	// 초기화 이전의 일시적 사각지대에서는 변수를 참조할 수 없음
	console.log(foo); // ReferenceError: foo is not defined

	let foo; // 변수 선언문에서 초기화 단계가 실행
	console.log(foo); // undefined

	foo = 1; // 할당문에서 할당 단계가 실행
	console.log(foo); // 1
	```
	

**3. const**
- 블록 레벨 스코프
- 반드시 선언과 동시에 초기화해야함
- let 키워드와 마찬가지로 변수 호이스팅이 발생하지 않는 것처럼 동작
- 재할당 금지
- 객체를 할당한 경우 값을 변경할 수 있음 (객체는 재할당 없이도 직접 변경이 가능하기 때문)

<br/>

# this

자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수

**this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정**

**- 일반 함수 호출 :** 전역 객체 <br/>
**- 메서드 호출 :** 메서드를 호출한 객체 <br/>
**- 생성자 함수 호출 :** 생성자 함수가 생성할 인스턴스

<br/>

# 실행 컨텍스트

소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역
⇒ 모든 코드는 실행 컨텍스트를 통해 실행되고 관리

식별자와 스코프는 실행 컨텍스트의 **렉시컬 환경**으로 관리하고 코드 실행 순서는 **실행 컨텍스트 스택**으로 관리

**1. 소스코드의 평가** <br/>
	  실행 컨텍스트를 생성하고 변수, 함수 등의 선언문만 먼저 실행 <br/>
   
**2. 소스코드의 실행** <br/>
	  선언문을 제외한 소스코드가 순차적으로 실행 (런타임 시작)


<br/>

# 클로저

중첩 함수가 **외부 함수의 스코프(변수, 상수 등)를 기억**하고, **외부 함수가 종료된 후에도** 해당 스코프를 참조할 수 있는 현상

<br/>

**클로저 사용 이유?** <br/>
상태가 의도치 않게 변경 되지 않도록 **안전하게 은닉**하고 **특정 함수에게만 상태 변경을 허용**하여 **상태를 안전하게 변경하고 유지**하기 위해 사용
