# 타이머 함수
## setTimeout/clearTimeout
- `setTimeout`은 두 번째 인수로 전달받은 시간(ms)으로 단 한 번 동작하는 타이머를 생성
- 이후 타이머가 만료되면 첫 번째 인수로 전달받은 콜백 함수가 호출

```javascript
// 1초 후 타이머가 만료되면 콜백 함수가 호출된다.
const timerId = setTimeout(() => console.log('Hi'), 1000);

// 1초 후 타이머가 만료되면 콜백 함수가 호출된다.
// 이때 콜백 함수에 'Lee'가 인수로 전달된다.
setTimeout((name) => console.log(`Hi ${name}`), 1000, 'Lee');

// 타이머 취소
clearTimeout(timerId);
```

## setInterval/clearInterval

-   `setInterval`  함수는 두 번째 인수로 전달받은 시간(ms)으로 반복 동작하는 타이머를 생성
-   이후 타이머가 만료될 때마다 첫 번째 인수로 전달받은 콜백 함수가 반복 호출
```javascript
let count = 1;
// 1초(1000ms) 후 타이머가 만료될 때마다 콜백 함수가 호출된다.
// setInterval 함수는 생성된 타이머를 식별할 수 있는 고유한 타이머 id를 반환한다.
const timeoutId = setInterval(() => {  
console.log(count); // 1 2 3 4 5
// count가 5이면 setInterval 함수가 반환한 타이머 id를 clearInterval 함수의 인수로 전달하여   
// 타이머를 취소한다. 타이머가 취소되면 setInterval 함수의 콜백 함수가 실행되지 않는다.  
if (count++ === 5) clearInterval(timeoutId);
}, 1000);

```

## 디바운스
-  짧은 시간 간격으로 이벤트가 연속해서 발생하면 이벤트 핸들러를 호출하지 않다가 일정 시간이 경과한 이후에  **이벤트 핸들러가 한 번만 호출** <br>
=> 짧은 시간 간격으로 발생하는 이벤트를 그룹화하여 마지막에 한 번만 이벤트 핸들러가 호출

- `resize` 이벤트 처리, `input` 요소에 입력된 값으로 ajax 요청하는 입력 필드 자동완성 UI 구현, 버튼 중복 클릭 방지 처리 등에 사용

<img src="https://velog.velcdn.com/images/qkrtofha94/post/f013bedb-1f24-449e-8bc9-c4a115c25719/image.png" width="400px">

## 스로틀
- 짧은 시간 간격으로 이벤트가 연속해서 발생하더라도 일정 시간 간격으로 이벤트 핸들러가 **최대 한 번만 호출**<br>
=> 짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서 일정 시간 단위로 이벤트 핸들러가 호출되도록 **호출 주기**를 만듬

- `scroll` 이벤트 처리, 무한 스크롤 UI 구현 등에 사용

<img src="https://velog.velcdn.com/images/qkrtofha94/post/bc3d8d74-95d4-4d61-ae7d-ae2e698c75af/image.png" width="400px">

# 비동기 프로그래밍

## 동기 처리와 비동기 처리
- 함수 실행 과정
	-  함수를 호출하면 함수 코드가 평가되어 **함수 실행 컨텍스트**가 생성
	-   이때 생성된 함수  **실행 컨텍스트**는 **실행 컨텍스트 스택(콜 스택)** 에 푸시되고 함수 코드가 실행
	-   함수 코드의 실행이 종료하면 함수 실행 컨텍스트는 실행 컨텍스트 스택에서 팝되어 제거

<img src="https://velog.velcdn.com/images/qkrtofha94/post/40517dcf-2c57-4441-bdcf-d3e8dba39217/image.png" width="400px">

- 자바스크립트 엔진은 **단 하나의 실행 컨텍스트 스택을 갖는다.**
=>함수를 실행할 수 있는 창구가 단 하나이기 때문에 동시에 **2개 이상의 함수를 동시에 실행할 수 없다.**

- 자바스크립트 엔진은 한 번에 하나의 태스크만 실행할 수 있는 `싱글 스레드` 방식으로 동작한다.
	- 싱글 스레드 방식은 한 번에 하나의 태스크만 실행할 수 있기 때문에 처리에 시간이 걸리는 태스크를 실행하는 경우 `블로킹`(작업 중단)이 발생한다.

- `동기 처리` : 현재 실행 중인 태스크가 종료할 때까지 다음에 실행될 태스크가 대기하는 방식
- `비동기 처리` : 반대로 현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식
	- 타이머 함수인 `setTimeout`, `setInterval`, `HTTP` 요청, 이벤트 핸들러는 **비동기 처리 방식**으로 동작

## 이벤트 루프와 태스크 큐
- `이벤트 루프` : 자바스크립트의 동시성을 지원하는 것, 브라우저에 내장되어 있는 기능

<img src="https://velog.velcdn.com/images/qkrtofha94/post/a5384a75-4318-44e3-b6eb-55bcb51292f4/image.png" width="400px">

-   `콜 스택`  : 소스코드 평가 과정에서 생성된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트 스택
-   `힙`  : 객체가 저장되는 메모리 공간<br>
				콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조

-   콜 스택과 힙으로 구성되어 있는 자바스크립트 엔진은 단순히 태스크가 요청되면 콜 스택을 통해 요청된 작업을 순차적으로 실행
-   비동기 처리에서 소스코드의 평가와 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 환경인  `브라우저`  또는  `Nods.js`가 담당
- 이를 위해 브라우저 환경은 태스크 큐와 이벤트 루프를 제공

# REST API
- `REST`는 HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처
- `REST API`는 REST를 기반으로 서비스 API를 구현한 것
- REST의 기본 원칙을 성실히 지킨 서비스 디자인을 `RESTful` 이라고 표현

## REST API 설계
-  URI는 리소스를 표현해야 한다.
-   리소스에 대한 행위는 **HTTP 요청 메서드**로 표현

<img src="https://velog.velcdn.com/images/qkrtofha94/post/960f347f-c3b4-41d9-8e07-3b5376932ee1/image.png" width="400px">

## 프로미스
-   자바스크립트에서는 비동기 처리를 하기 위한 하나의 패턴으로  `콜백 함수`를 사용한다.
    
-   그러나 콜백 패턴은 단점이 있다.
    
    -   콜백 헬로 인해  `가독성 나쁨`
    -   `에러 처리`가 곤란함
    -   여러 개의  `비동기 처리`를 한 번에 처리하는 데 한계가 있음
-   따라서 ES6에서는 비동기 처리를 위한 또 다른 패턴으로  `프로미스`를 도입했다.
    
-   프로미스는 전통적인 콜백 패턴이 가진 단점을 보완하며  **비동기 처리 시점**을 명확하게 표현할 수 있다.
