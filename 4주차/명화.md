
# 디바운스(debounce)

짧은 시간 간격으로 이벤트가 연속해서 발생하면 이벤트 핸들러를 호출하지 않다가 일정 시간이 경과한 이후에 이벤트 핸들러가 한 번만 호출<br />
⇒ 짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 **마지막에 한 번만 이벤트 핸들러가 호출**

**사용 예시 :** resize 이벤트, input 이벤트, 버튼 중복 클릭 방지 처리 등

<img src="https://velog.velcdn.com/images/smh0116/post/c9778777-120f-4d42-9d95-fb09a9266606/image.png" width="500" />

<br />

# 스로틀(throttle)

짧은 시간 간격으로 이벤트가 연속해서 발생하더라도 일정 시간 간격으로 이벤트 핸들러가 최대 한 번만 호출<br />
⇒ 짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 **호출 주기를 만들어 일정 시간 단위로 이벤트 핸들러를 호출**

**사용 예시 :** scroll 이벤트, 무한 스크롤 UI 구현 등

<img src="https://velog.velcdn.com/images/smh0116/post/3bb64d01-bd0e-490d-a653-3c0ca1b8e02c/image.png" width="500" />

<br />

# 동기 처리 / 비동기 처리

자바스크립트 엔진은 한 번에 하나의 태스크만 실행할 수 있는 **싱글 스레드**

**싱글 스레드 방식**은 한 번에 하나의 테스크만 실행할 수 있기 때문에 **처리에 시간이 걸리는 태스크를 실행하는 경우 블로킹(작업 중단)이 발생**

**동기 처리 방식**<br />
태스크를 순서대로 하나씩 처리하므로 **실행 순서가 보장**된다는 장점이 있지만, **앞선 태스크가 종료할 때까지 이후 태스크들이 블로킹**이 된다는 단점이 있음

**비동기 처리 방식**<br />
현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧장 실행하므로 **블로킹이 발생하지 않은** 장점이 있지만, 태스크 **실행 순서가 보장되지 않는** 단점이 있음

<br />

# 이벤트 루프 / 태스크 큐

자바스크립트의 동시성을 지원하는 것 **⇒ 이벤트 루프**

<img src="https://velog.velcdn.com/images/smh0116/post/e6d0de8c-f6ab-4e7e-91f1-f15636957627/image.png" width="400" />

**힙 :** 객체가 저장되는 메모리 공간<br /><br />
**콜 스택 :** 소스코드 평가 과정에서 생성된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트 스택<br /><br />
**이벤트 루프 :** 콜 스택에 현재 실해중인 컨텍스트가 있는지, 테스크 큐에 대기 중인 함수가 있는지 반복해서 확인<br />
&emsp;**⇒ 콜 스택이 비어 있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동**<br /><br />
**태스크 큐 :** 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역

<br />

# REST API

REST를 기반으로 서비스 API를 구현한 것

**REST :** HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처<br />
**RESTful :** REST의 기본 원칙을 성실히 지킨 서비스 디자인

| HTTP 요청 메서드 | 목적 |
|--|--|
| GET | 모든/특정 리소스 취득 |
| POST | 리소스 생성 |
| PUT | 리소스 전체 교체 |
| PATCH | 리소스 일부 수정 |
| DELETE | 모든/특정 리소스 삭제 |

<br />

# 프로미스

자바스크립트에서 비동기 작업의 성공 결과 또는 실패 이유를 처리할 수 있도록 상태와 결과를 관리하는 객체

<img src="https://velog.velcdn.com/images/smh0116/post/8ec6c139-1145-45ba-9d75-60ebb0fd4e1c/image.png" width="450" />
<img src="https://velog.velcdn.com/images/smh0116/post/f42bd50d-9ad6-46dd-9a15-790091b1129e/image.png" width="500" />

프로미스는 ```then```, ```catch```, ```finally``` 후속 처리 메서드를 통해 **콜백 헬을 해결**

**콜백 헬 :** 콜백 함수 호출이 중첩되어 복잡도가 높아지는 현상

**```Promise.all```** : 여러개의 비동기 처리를 병렬로 처리할 때 사용<br />
**```Promise.race```**: 가장 먼저 완료된 작업의 결과를 반환

<br />

# 마이크로 태스크 큐

프로미스의 후속 처리 메서드의 콜백 함수가 일시 저장 됨
<br /><br />
**마이크로 태스크 큐는 태스크 큐와 별도!**<br />

**우선순위 :** 마이크로 태스크 큐 **`>`** 태스크 큐<br />

> **이벤트 루프는 콜 스택이 비면**
> 1. 먼저 마이크로 태스크 큐에서 대기하고 있는 함수를 가져와 실행
> 2. 마이크로 태스크 큐가 비면 태스크 큐에 대기하고 있는 함수를 가져와 실행

<br />

# async / await

프로미스를 기반으로 동작<br />
`async`와 `await`를 사용하면 비동기 코드를 동기 코드처럼 작성할 수 있어, 가독성이 높아지고 에러 처리가 간단해짐

**async :** 함수가 항상 프로미스를 반환하도록 선언하고, 내부에서 `await` 사용을 가능하게 함<br />
**await :**  비동기 작업이 완료될 때까지 코드 실행을 일시 중지하고, 완료되면 해당 결과를 반환
