# 딥다이브 주차 별 정리

## 개요
### 1. 자바스크립트 특징
### 2. 변수
### 3. 표현식과 문
### 4. 객체 리터럴
### 5. 원시 값과 객체의 비교 (데이터 타입)
<br>

## 자바스크립트 특징
1. 자바스크립트는 HTML, CSS와 함께 웹을 구성하는 요소 중 하나로 **웹 브라우저에서 동작하는 유일한 프로그래밍 언어다.**
2. 자바스크립트는 개발자가 별도의 컴파일 작업을 수행하지 않는 **인터프리터 언어다.**
3. 자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 **멀티 패러다임 프로그래밍 언어다.**
4. 자바스크립트는 클래스 기반 객체지향 언어보다 효율적이면서 **강력한 프로토타입 기반의 객체지향 언어다.**
<br>

### ▪️ 브라우저와 자바스크립트
- 자바스크립트는 브라우저뿐만 아니라 서버에서도 실행할 수 있습니다. 이 외에도 [자바스크립트 엔진(JavaScript engine)](https://en.wikipedia.org/wiki/JavaScript_engine)이라 불리는 특별한 프로그램이 들어 있는 모든 디바이스에서도 동작합니다.

  브라우저엔 '자바스크립트 가상 머신’이라 불리는 엔진이 내장되어 있습니다.

  > 추후 메인 스레드, 서버 node 그리고 브라우저 단에서의 자바스크립트 엔진의 동작 원리를 이해해보자.
  <br>

  ## 변수
  : 데이터를 저장하기 위해 쓰이는 저장소. '이름이 붙은 저장소'라고 생각하면 쉽다.<br>
  = 값을 호출하거나 **다시 재사용하기** 위해서 정보를 저장해놓는 용도.
  <br>

  ### ▪️ 식별자
  : 실행 컨텍스트에 의해서 평가된 선언문이 할당이 일어났을 때, **할당 데이터(원시, 참조)** 값을 저장한 메모리 주소.<br>
  `개인적으로 정리한 식별자의 정의며 (* 쉽게 C언어의 포인터 개념과 유사하다고 생각.)`<br>
  => **식별자는 값이 아니라 메모리 주소를 기억하고 있다.** 
  
  ![](https://velog.velcdn.com/images/smh0116/post/861caa95-5055-4caf-8311-6c7e96f714ba/image.png)
<br>

  할당 이전 자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행한다.
  - 선언 단계 : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
  - 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화 한다.
  <br>

  ### 변수 호이스팅
 : 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라 한다.
 
    console.log(score); // undefined
    
    var score; // 변수 선언문 ⇒ 런타임 이전에 먼저 실행
    score = 80; // 값의 할당 ⇒ 런타임에 실행
    
    console.log(score); // 80

변수 선언이 런타임(소스코드가 한 줄씩 순차적으로 실행되는 시점)이 아니라 그 이전 단계에서 먼저 실행되기 때문에 ReferenceError(참조에러)가 발생하지 않고 undefined가 출력됨.

<br>

## 표현식과 문

### 표현식
표현식은 값으로 평가될 수 있는 문이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.

    // 리터럴 표현식
    10
    'hello'

    // 식별자 표현식 (선언이 이미 존재한다고 가정)
    sum
    person.name
    arr[1]

    // 연산자 표현식
    10 + 20
    sum = 10
    sum !== 10

    // 험수/메서드 호출 표현식 (선언이 이미 존재한다고 가정)
    square()
    person.getname()

이처럼 표현식은 리터럴, 식별자(변수, 함수 등의 이름), 현산자, 함수 호출 등의 조합으로 이루어 질 수 있다.
다양한 표현식이 있지만 값으로 평가된다는 점에서 모두 동이랗다. 즉, **값으로 평가될 수 있는 문은 모두 표현식이다.**

<br/>

### 문
프로그램을 구성하는 기본 단위이자 최소 실행 단위. <br/>
문을 명령문이라고도 부르며, 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다.

<br/>

### 표현식인 문과 표현식이 아닌 문
표현식은 문의 일부일 수도 있고 그 자체로 문이 될 수도 있다.

    // 표현식이 아닌 문은 값처럼 사용할 수 없다.
    var foo = var x;  // syntaxError: Unexpected token var

    // 변수 선언문은 표현식이 아닌 문이다.
    var x;

    // 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.
    x = 100;

    // 표현식인 문은 값처럼 사용할 수 있다.
    var foo = x = 100;
    console.log(foo);  // 100

<br/>

## 객체 리터럴

### 객체란?
자바스크립트는 객체 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 "모든 것"이 객체다.<br/>
원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체다.<br/>
<br/>

원시 타입은 단 하나의 값만 나타내지만 객체 타입은 다양한 타입의 값(원시 값 또는 다른 객체)을 하나의 단위로 구성한 복합적인 자료구조다. <br/>

<br/>

### 객체를 나타내는 구조
    프로퍼티 : 객체의 상태를 나타내는 값(data)
    메서드 : 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)

> 객체와 함수
```
  자바스크립트의 객체는 함수와 밀접한 관계를 가진다. 함수로 객체를 생성하기도 하며 함수 자체가 객체이기도 하다.
  자바스크립트에서 함수와 객체는 분리해서 생각할 수 없는 개념이다.
  즉, 객체를 이해해야 함수를 제대로 이해할 수 있고, 반대로 함수를 이해해야 객체를 정확히 이해할 수 있다.
```

<br/>

### ES6에서 추가된 객체 리터럴의 확장기능
ES6에서는 더욱 간결하고 표현력 있는 객체 리러털의 확장 기능을 제공한다.

    // ES5
    var x = 1, y = 2;

    var obj = {
      x: x,
      y: y
    };

    console.log(obj); //  {x: 1, y: 2}


    // ES6
    let x = 1, y = 2;

    // 프로퍼티 축양 표현
    const obj = {x , y};

    console.log(obj) // {x: 1, y: 2}
<br/>

  외 ES5에서 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성하려면 객체 리터럴 외부에서 대괄호 [...] 표기법을 사용해야 했다.<br/>

  ES6 에서는 객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성할 수 있게 됐다.

      const prefix = 'prop';
      let i = 0;
      // 객체 리터럴 내부에서 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성

      const obj = {
        [`${prefix} - ${++i}`]: i,
        [`${prefix} - ${++i}`]: i,
        [`${prefix} - ${++i}`]: i,
      };

      consolg.log(obj); //  {prop-1: 1, prop-2: 2, prop-3: 3} 
  <br/>

#### 메서드 축약 표현
    // ES5
    var obj = {
      name : 'Lee',
      sayHi: function() {
        console.log('Hi! '+ this.name );
      }
    };

    obj.sayHi(); // Hi! Lee

    // ES6
    var obj = {
      name : 'Lee',
      
      // 메서드 축약표현
      sayHi() {
        console.log('Hi! '+ this.name );
      }
    };

    obj.sayHi(); // Hi! Lee


## 원시 값과 객체의 비교

### 데이터 타입

#### 원시 타입(기본형)
1. 숫자(Number)
2. 문자열(String)
3. 불리언(Boolean)
4. null
5. undefined
6. 심볼(Symbol)

#### 참조 타입(참조형)

1. 객체(Objcet)
2. 배열(Array)
3. 함수(Function)
4. 날짜(Date)
5. 정규표현식(RegExp)
6. Map, WeakMap, Set, WeakSet 등

**기본형과 참조형을 구분하는 기준**
> "일반적으로 **기본형은** 할당이나 연산시 복제되고 **참조형은** 참조된다고 알려져 있습니다. <br> 엄밀히 말하면 둘 모두 복제를 합니다. 다만 기본형은 값이 담긴 주솟값을 바로 복제하는 반면 참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다는 점이 다릅니다."
<br> 출처 : 코어자바스크립트_정재남 지음

<br/>

## 원시 값 / 객체

|**원시 타입**|**객체 타입**|
|--|--|
|원시 값은 **변경 불가능**한 값 (읽기 전용 값)|객체는 **변경 가능**한 값|
|변수에 **실제 값**이 저장|변수에 **참조 값**이 저장|
|변수를 다른 변수에 할당하면 **원시 값이 복사**되어 전달 ⇒ **값에 의한 전달**|변수를 다른 변수에 할당하면 **참조 값이 복사**되어 전달 ⇒ **참조에 의한 전달**|

<img src="https://velog.velcdn.com/images/smh0116/post/a7de198f-e82b-4b3c-8501-30c4bddbd3aa/image.png" alt="" width="700" />

두 변수의 원시 값은 **서로 다른 메모리에 저장된 별개의 값**이기 때문에 재할당을 통해 값을 변경해도 서로 간섭할 수 없음

<br/>

<img src="https://velog.velcdn.com/images/smh0116/post/23180230-3402-4020-bcc6-cc0f297922db/image.png" alt="" width="700" />

각 변수에 저장된 **메모리 주소는 다르지만 동일한 참조 값**을 가져, **두 개의 식별자가 하나의 객체를 공유**한다는 것을 의미
